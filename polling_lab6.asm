.data

head: .space 1000       #δεσμεύω χώρο για έως 1000 χαρακτήρες
lab6: .asciiz "POLLED OPERATION - LAB 6 \n\n"
menu: .asciiz "String (MAX 1000 CHARACTERS): "
newline: .asciiz "\n"
exit: .asciiz "EXIT!"
menu2: .asciiz "Enter 1 to give new string, 2 to exit: "

.text
.globl main

main:

la $a0,lab6
jal print_string

again:
	la $a0,menu            
	jal print_string


	la $a0, head            #περνάω ως όρισμα την διεύθυνση του μπλοκ μνήμης που χω δεσμεύσει
	jal read_string		
	
	la $a0,head	 
	jal lowercaseToUppercase	#καλώ την υπορουτίνα μετατροπής μικρών σε κεφαλαία
	la $a0,newline
	jal print_string        


	move $a0,$v0		
	jal print_string	#εκτυπώνω τα κεφαλαία

	la $a0,newline          
	jal print_string 
	la $a0,menu2           
	jal print_string

	li $v0,5
	syscall
	move $t9, $v0
beq $t9, 1, again 	#αν θέλει να ξαναδώσει string

la $a0,newline          #Exit
jal print_string  
la $a0,exit
jal print_string

li $v0,10
syscall	
		
###########################################################################################################
###########################################################################################################
#FUNCTIONS
###########################################################################################################
###########################################################################################################
#RECEIVER

read_ch:

ready1:
	lw $t0,0xffff0000	#βάζουμε το περιεχόμενο απ'το receiver control στον $t0 
	andi $t0,$t0,1		#έλεγχος για το lsb(ready bit), andi γιατί μόνο στο and 1,1 έχουμε τιμή 1 
beq $t0,0,ready1     	#περιμένουμε μέχρι να είναι έτοιμος

lw $v0,0xffff0004       #εάν ή όταν είναι φορτώνω το περιεχόμενο του receiver data στον $v0
	
jr $ra


#############################################################################################################
#############################################################################################################
#TRANSMITTER

write_ch:

ready2:
	lw $t0,0xffff0008	#εκχωρώ το περιεχόμενο του transmitter control στον $t0
	andi $t0,$t0,1		#ελέγχω το lsb(ready bit)
beq $t0,0,ready2      	#περιμένουμε μέχρι να είναι έτοιμος

sw $a0,0xffff000c       #εάν ή όταν είναι φορτώνω το περιεχόμενο του $a0 στο transmitter data  

jr $ra

####################################################################################################################################################
####################################################################################################################################################
read_string:

sub $sp,$sp,4	#δημιουργώ χώρο στην στοίβα για τον $ra, ώστε να κρατάμε την διεύθυνση επιστροφής
sw $ra, 0($sp)	#κρατάω την διεύθυνση επιστροφής
li $t5, 0 	#μετρητής για την συμβολοσειρά

readLoop: 
	jal read_ch			#καλείται η read_ch υπορουτίνα για να διαβαστεί χαρακτήρας
	sb $v0, head($t5) 		#αποθηκεύω το lsb 
	beq $v0,0, end			#έλεγχος για /0	
	beq $v0,10, end			#έλεγχος αν έχει πατηθεί το enter
	addi $t5, $t5,1			#αυξάνω τον $t5
	move $a0, $v0			#όρισμα στην write_ch (δηλαδη τελικα το φορτώνω στο transmitter data)		
	jal write_ch			# $a0<--$v0 και καλώ την υπορουτίνα write_ch για να τυπώσει τον χαρακτήρα
j readLoop

end:
	
lw $ra, 0($sp)		#επαναφέρουμε τον $ra	
addi $sp,$sp,4		#αποδέσμευση στοίβας	
jr $ra	

#####################################################################################################################################################
#####################################################################################################################################################

print_string:

sub $sp,$sp,4	 	#δημιουργώ χώρο στην στοίβα για τον $ra, ώστε να κρατάμε την διεύθυνση επιστροφής
sw  $ra,0($sp)		#κρατάω την διεύθυνση επιστροφής
li $t1,0
move $t2,$a0            

loopPrint:
	add $t3,$t1,$t2
	lb $a0,0($t3)
	jal write_ch
	beq $a0,0,end2		#έλεγχος για /0
	beq $a0,10,end2		#έλεγχος αν έχει πατηθεί το enter
	addi $t1,$t1,1
j loopPrint

end2:

lw $ra,0($sp) 		#επαναφέρουμε τον $ra
addi $sp,$sp,4		#αποδέσμευση στοίβας	
jr $ra

##########################################################################################################################################
##########################################################################################################################################

lowercaseToUppercase:

sub $sp $sp,4
sw $ra,0($sp)

li $t4,0	#για το size συμβολοσειράς,μετρήτης sizeLoop


sizeLoop:	
	bge $t4,1000,endLoop
	add $t5,$a0,$t4		#ο $a0 δείχνει στην αρχή οπότε κάθε που αυξάνω τον $t3 θα μετακινω τον $t5 στο δίπλα χαρακτήρα
	lb $t8,0($t5)		#διαβάζω τον χαρακτήρα στην διευθυνση που δείχνει ο $t5
	beq $t8,3,endLoop	#έλεγχος για τέλος συμβολοσειράς (ASCII CODE 3: END OF TEXT), αν τελειώσει κάνει break
	addi $t4,$t4,1		#αυξάνω το size,μετρητή
j sizeLoop

endLoop:

li $t3,0     #για να προσπελαύνω την μνήμη		
li $t2,0     #για την συνθήκη επανάληψης

convert:
	bge $t2,$t4,convEnd	
	add $t3,$a0,$t2			#πέρνω την διεύθυνση του κάθε χαρακτήρα της συμβολοσειράς
	lb $t7,($t3)			#φορτώνω το byte στον $t7
	blt $t7,97,elseLab		#ελέγχω αν ανήκει στα μικρά γράμματα σύμφωνα με τον ASCII Code.
	bgt $t7,122,elseLab		
	addi $t7,$t7,-32		#αν είναι μικρό το κάνω κεφαλαίο
	sb $t7,0($t3)			#αποθηκεύω στην μνήμη το κεφαλαίο γράμμα
	elseLab:
	addi $t2,$t2,1			#αύξηση μετρητή
j convert

convEnd:
		
la $v0,head
lw $ra,0($sp)
addi $sp,$sp,4
jr $ra				
